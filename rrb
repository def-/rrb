#!/bin/sh

# This is the reverse rsync backup (rrb) utility. It has to be run on the
# backup server and will then make a backup of a specified directory of a
# client machine via ssh, rsh, or any other remote shell or the localhost using
# rsync with hardlinks. See the config.example for more information about the
# configuration of rrb for a client.
#
# Further features include an exclusion file, the resume of a failed transfer,
# customizable commands to be executed before running, after running, after a
# failure, after a success.
#
# You can use fdupes or a similar tool to hardlink between multiple machines.
#
# No backups will be done automatically. You have to run rrb by hand every time
# you want to make a backup. Use cron to make regular backups, at to make
# backups at a specific time, or a custom script using sxc, or portknocking, or
# whatever to enable the client to request a backup.
#
# If you want to automize backups via ssh, you can use public key
# authentication. So if you do full-system backups from your backup server, it
# will have root access to all the backup clients. Root access on the server
# means root access on all the clients and a loss of all the backups. Secure
# the server and save backups offline, too.
#
# The backups can be made accessible in any manner, like NFS, SMB, or a custom
# script that tars the files and sends them over the network. Please use your
# creativity.

# -----------------------------------------------------------------------------

# Exit on every fail.
set -e

HELP="Usage: $0 config"

# Exit codes
EX_USAGE=64
EX_SOFTWARE=70
EX_CONFIG=78
EX_FILE=100
EX_RUNNING=101

# Unset variables from config file.
SRC=
EXCLUDES_FILE=
DEST_DIR=
BEFORE_CMD=
AFTER_CMD=
FAIL_CMD=
SUCCESS_CMD=
RSYNC_OPTS=

log()
{
  echo "$*" >&2
}

run()
{
  if [ "" != "$*" ]; then
    echo "$*" | sh
  fi
}

if [ "" == "$1" ]; then
  log "Config file missing."
  log "$HELP"
  exit $EX_USAGE
fi

. $1

if [ "" == "$SRC" -o "" == "$DEST_DIR" ]; then
  log 'Invalid config file, has to include at least $SRC and $DEST_DIR.'
  log "$HELP"
  exit $EX_CONFIG
fi

LATEST_DIR="$DEST_DIR/latest"
TMP_DIR="$DEST_DIR/.tmp"
NEW_DIR="$DEST_DIR/`date +%FT%T`"
LOCK_FILE="$DEST_DIR/.lock"

if [ -e "$NEW_DIR" ]; then
  log "Backup directory $NEW_DIR already exists."
  exit $EX_FILE
fi

if [ "" != "$EXCLUDES_FILE" ]; then
  RSYNC_OPTS="$RSYNC_OPTS --exclude-from=$EXCLUDES_FILE"
fi

if [ -L "$LATEST_DIR" ]; then
  RSYNC_OPTS="$RSYNC_OPTS --link-dest=$LATEST_DIR"
fi

if [ -e "$LOCK_FILE" ]; then
  PID=`cat $LOCK_FILE`
  if ps a | grep "^$PID" > /dev/null; then
    log "Process $PID already runs on $DEST_DIR. Remove $LOCK_FILE if not."
    exit $EX_RUNNING
  fi
fi


echo $$ > $LOCK_FILE

run "$BEFORE_CMD"

cleanup()
{
  if [ 0 -eq $? ]; then
    run "$SUCCESS_CMD"
  else
    run "$FAIL_CMD"
  fi

  run "$AFTER_CMD"

  rm -f $LOCK_FILE
}

# Always call, event on success.
trap cleanup EXIT

rsync -avzP --delete --delete-excluded $RSYNC_OPTS $SRC "$TMP_DIR" \
|| [ 24 -eq $? ]

mv $TMP_DIR $NEW_DIR
rm -f $LATEST_DIR
ln -sf $NEW_DIR $LATEST_DIR
